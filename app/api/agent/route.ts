import { NextResponse } from "next/server";
import type { AgentHistoryMessage, AgentRequest, AgentResponse, WizardContext } from "@/app/types/agent";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

const MAX_HISTORY_ITEMS = 8;

type WalletRouteResponse = {
  success?: boolean;
  walletAddress?: string;
  network?: string;
  error?: string;
};

function getBackendBaseUrl() {
  return process.env.SELUN_BACKEND_URL?.trim() || "http://localhost:8787";
}

function formatContext(context?: WizardContext): string {
  if (!context) return "No wizard context provided.";

  return [
    `Risk tolerance: ${context.riskTolerance || "Not provided"}`,
    `Investment horizon: ${context.investmentHorizon || "Not provided"}`,
    `Portfolio summary: ${context.portfolioSummary || "Not provided"}`,
    `Objective: ${context.objective || "Not provided"}`,
    `Wallet: ${context.walletAddress || "Not connected yet"}`,
  ].join("\n");
}

function shortenAddress(value: string): string {
  if (value.length <= 14) return value;
  return `${value.slice(0, 8)}...${value.slice(-6)}`;
}

function summarizeHistory(history?: AgentHistoryMessage[]): string {
  if (!history || history.length === 0) return "None";
  return history
    .slice(-MAX_HISTORY_ITEMS)
    .map((entry) => `${entry.role === "assistant" ? "Selun" : "User"}: ${entry.content}`)
    .join(" | ");
}

function buildAgentKitResponse(
  payload: AgentRequest,
  walletAddress: string,
  network: string,
) {
  const message = payload.userMessage.toLowerCase();
  const contextSummary = formatContext(payload.context);
  const historySummary = summarizeHistory(payload.history);
  const identityLine = `Selun AgentKit identity is online on ${network} with wallet ${shortenAddress(walletAddress)}.`;

  if (message.includes("wallet") || message.includes("address")) {
    return `${identityLine} Full wallet: ${walletAddress}.`;
  }

  if (message.includes("network") || message.includes("chain")) {
    return `${identityLine} Active chain: ${network}.`;
  }

  return [
    identityLine,
    "Proceed in the wizard: Configure -> Review & Authorize -> Processing.",
    `Current context: ${contextSummary}`,
    `Recent exchange: ${historySummary}`,
    "Selun decisions are generated by backend doctrine and Coinbase AgentKit execution.",
  ].join("\n");
}

export async function POST(req: Request): Promise<NextResponse<AgentResponse>> {
  let payload: AgentRequest;

  try {
    payload = (await req.json()) as AgentRequest;
  } catch {
    return NextResponse.json(
      {
        success: false,
        error: "Invalid JSON payload.",
      },
      { status: 400 },
    );
  }

  if (!payload.userMessage?.trim()) {
    return NextResponse.json(
      {
        success: false,
        error: "userMessage is required.",
      },
      { status: 400 },
    );
  }

  try {
    const walletResponse = await fetch(`${getBackendBaseUrl()}/agent/wallet`, {
      method: "GET",
      cache: "no-store",
    });
    const walletData = (await walletResponse.json()) as WalletRouteResponse;

    if (!walletResponse.ok || !walletData.walletAddress || !walletData.network) {
      return NextResponse.json(
        {
          success: false,
          error: walletData.error ?? "Selun AgentKit wallet is unavailable.",
        },
        { status: walletResponse.status || 502 },
      );
    }

    const responseText = buildAgentKitResponse(payload, walletData.walletAddress, walletData.network);

    return NextResponse.json({
      success: true,
      response: responseText,
    });
  } catch (error) {
    console.error("Selun agent route error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Selun agent failed to respond.",
      },
      { status: 500 },
    );
  }
}
